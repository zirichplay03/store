// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: store.proto
#ifndef GRPC_store_2eproto__INCLUDED
#define GRPC_store_2eproto__INCLUDED

#include "store.pb.h"

#include <functional>
#include <grpcpp/generic/async_generic_service.h>
#include <grpcpp/support/async_stream.h>
#include <grpcpp/support/async_unary_call.h>
#include <grpcpp/support/client_callback.h>
#include <grpcpp/client_context.h>
#include <grpcpp/completion_queue.h>
#include <grpcpp/support/message_allocator.h>
#include <grpcpp/support/method_handler.h>
#include <grpcpp/impl/proto_utils.h>
#include <grpcpp/impl/rpc_method.h>
#include <grpcpp/support/server_callback.h>
#include <grpcpp/impl/server_callback_handlers.h>
#include <grpcpp/server_context.h>
#include <grpcpp/impl/service_type.h>
#include <grpcpp/support/status.h>
#include <grpcpp/support/stub_options.h>
#include <grpcpp/support/sync_stream.h>

namespace fitness {

// Основной сервис фитнес-центра
class FitnessService final {
 public:
  static constexpr char const* service_full_name() {
    return "fitness.FitnessService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status GetServices(::grpc::ClientContext* context, const ::fitness::Empty& request, ::fitness::ServiceList* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::fitness::ServiceList>> AsyncGetServices(::grpc::ClientContext* context, const ::fitness::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::fitness::ServiceList>>(AsyncGetServicesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::fitness::ServiceList>> PrepareAsyncGetServices(::grpc::ClientContext* context, const ::fitness::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::fitness::ServiceList>>(PrepareAsyncGetServicesRaw(context, request, cq));
    }
    virtual ::grpc::Status LoginUser(::grpc::ClientContext* context, const ::fitness::LoginRequest& request, ::fitness::LoginResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::fitness::LoginResponse>> AsyncLoginUser(::grpc::ClientContext* context, const ::fitness::LoginRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::fitness::LoginResponse>>(AsyncLoginUserRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::fitness::LoginResponse>> PrepareAsyncLoginUser(::grpc::ClientContext* context, const ::fitness::LoginRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::fitness::LoginResponse>>(PrepareAsyncLoginUserRaw(context, request, cq));
    }
    virtual ::grpc::Status RegisterUser(::grpc::ClientContext* context, const ::fitness::RegisterRequest& request, ::fitness::RegisterResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::fitness::RegisterResponse>> AsyncRegisterUser(::grpc::ClientContext* context, const ::fitness::RegisterRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::fitness::RegisterResponse>>(AsyncRegisterUserRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::fitness::RegisterResponse>> PrepareAsyncRegisterUser(::grpc::ClientContext* context, const ::fitness::RegisterRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::fitness::RegisterResponse>>(PrepareAsyncRegisterUserRaw(context, request, cq));
    }
    virtual ::grpc::Status GetTrainers(::grpc::ClientContext* context, const ::fitness::Empty& request, ::fitness::TrainerList* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::fitness::TrainerList>> AsyncGetTrainers(::grpc::ClientContext* context, const ::fitness::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::fitness::TrainerList>>(AsyncGetTrainersRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::fitness::TrainerList>> PrepareAsyncGetTrainers(::grpc::ClientContext* context, const ::fitness::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::fitness::TrainerList>>(PrepareAsyncGetTrainersRaw(context, request, cq));
    }
    virtual ::grpc::Status GetTrainerSchedule(::grpc::ClientContext* context, const ::fitness::TrainerScheduleRequest& request, ::fitness::TrainerScheduleResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::fitness::TrainerScheduleResponse>> AsyncGetTrainerSchedule(::grpc::ClientContext* context, const ::fitness::TrainerScheduleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::fitness::TrainerScheduleResponse>>(AsyncGetTrainerScheduleRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::fitness::TrainerScheduleResponse>> PrepareAsyncGetTrainerSchedule(::grpc::ClientContext* context, const ::fitness::TrainerScheduleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::fitness::TrainerScheduleResponse>>(PrepareAsyncGetTrainerScheduleRaw(context, request, cq));
    }
    virtual ::grpc::Status GetTrainerClients(::grpc::ClientContext* context, const ::fitness::TrainerClientsRequest& request, ::fitness::TrainerClientsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::fitness::TrainerClientsResponse>> AsyncGetTrainerClients(::grpc::ClientContext* context, const ::fitness::TrainerClientsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::fitness::TrainerClientsResponse>>(AsyncGetTrainerClientsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::fitness::TrainerClientsResponse>> PrepareAsyncGetTrainerClients(::grpc::ClientContext* context, const ::fitness::TrainerClientsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::fitness::TrainerClientsResponse>>(PrepareAsyncGetTrainerClientsRaw(context, request, cq));
    }
    virtual ::grpc::Status GetContacts(::grpc::ClientContext* context, const ::fitness::Empty& request, ::fitness::ContactList* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::fitness::ContactList>> AsyncGetContacts(::grpc::ClientContext* context, const ::fitness::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::fitness::ContactList>>(AsyncGetContactsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::fitness::ContactList>> PrepareAsyncGetContacts(::grpc::ClientContext* context, const ::fitness::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::fitness::ContactList>>(PrepareAsyncGetContactsRaw(context, request, cq));
    }
    virtual ::grpc::Status GetPrices(::grpc::ClientContext* context, const ::fitness::Empty& request, ::fitness::PriceList* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::fitness::PriceList>> AsyncGetPrices(::grpc::ClientContext* context, const ::fitness::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::fitness::PriceList>>(AsyncGetPricesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::fitness::PriceList>> PrepareAsyncGetPrices(::grpc::ClientContext* context, const ::fitness::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::fitness::PriceList>>(PrepareAsyncGetPricesRaw(context, request, cq));
    }
    virtual ::grpc::Status BookTraining(::grpc::ClientContext* context, const ::fitness::TrainingBookingRequest& request, ::fitness::TrainingBookingResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::fitness::TrainingBookingResponse>> AsyncBookTraining(::grpc::ClientContext* context, const ::fitness::TrainingBookingRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::fitness::TrainingBookingResponse>>(AsyncBookTrainingRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::fitness::TrainingBookingResponse>> PrepareAsyncBookTraining(::grpc::ClientContext* context, const ::fitness::TrainingBookingRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::fitness::TrainingBookingResponse>>(PrepareAsyncBookTrainingRaw(context, request, cq));
    }
    virtual ::grpc::Status AddBalance(::grpc::ClientContext* context, const ::fitness::BalanceRequest& request, ::fitness::BalanceResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::fitness::BalanceResponse>> AsyncAddBalance(::grpc::ClientContext* context, const ::fitness::BalanceRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::fitness::BalanceResponse>>(AsyncAddBalanceRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::fitness::BalanceResponse>> PrepareAsyncAddBalance(::grpc::ClientContext* context, const ::fitness::BalanceRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::fitness::BalanceResponse>>(PrepareAsyncAddBalanceRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      virtual void GetServices(::grpc::ClientContext* context, const ::fitness::Empty* request, ::fitness::ServiceList* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetServices(::grpc::ClientContext* context, const ::fitness::Empty* request, ::fitness::ServiceList* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void LoginUser(::grpc::ClientContext* context, const ::fitness::LoginRequest* request, ::fitness::LoginResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void LoginUser(::grpc::ClientContext* context, const ::fitness::LoginRequest* request, ::fitness::LoginResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void RegisterUser(::grpc::ClientContext* context, const ::fitness::RegisterRequest* request, ::fitness::RegisterResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void RegisterUser(::grpc::ClientContext* context, const ::fitness::RegisterRequest* request, ::fitness::RegisterResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetTrainers(::grpc::ClientContext* context, const ::fitness::Empty* request, ::fitness::TrainerList* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetTrainers(::grpc::ClientContext* context, const ::fitness::Empty* request, ::fitness::TrainerList* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetTrainerSchedule(::grpc::ClientContext* context, const ::fitness::TrainerScheduleRequest* request, ::fitness::TrainerScheduleResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetTrainerSchedule(::grpc::ClientContext* context, const ::fitness::TrainerScheduleRequest* request, ::fitness::TrainerScheduleResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetTrainerClients(::grpc::ClientContext* context, const ::fitness::TrainerClientsRequest* request, ::fitness::TrainerClientsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetTrainerClients(::grpc::ClientContext* context, const ::fitness::TrainerClientsRequest* request, ::fitness::TrainerClientsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetContacts(::grpc::ClientContext* context, const ::fitness::Empty* request, ::fitness::ContactList* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetContacts(::grpc::ClientContext* context, const ::fitness::Empty* request, ::fitness::ContactList* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetPrices(::grpc::ClientContext* context, const ::fitness::Empty* request, ::fitness::PriceList* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetPrices(::grpc::ClientContext* context, const ::fitness::Empty* request, ::fitness::PriceList* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void BookTraining(::grpc::ClientContext* context, const ::fitness::TrainingBookingRequest* request, ::fitness::TrainingBookingResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void BookTraining(::grpc::ClientContext* context, const ::fitness::TrainingBookingRequest* request, ::fitness::TrainingBookingResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void AddBalance(::grpc::ClientContext* context, const ::fitness::BalanceRequest* request, ::fitness::BalanceResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void AddBalance(::grpc::ClientContext* context, const ::fitness::BalanceRequest* request, ::fitness::BalanceResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::fitness::ServiceList>* AsyncGetServicesRaw(::grpc::ClientContext* context, const ::fitness::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::fitness::ServiceList>* PrepareAsyncGetServicesRaw(::grpc::ClientContext* context, const ::fitness::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::fitness::LoginResponse>* AsyncLoginUserRaw(::grpc::ClientContext* context, const ::fitness::LoginRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::fitness::LoginResponse>* PrepareAsyncLoginUserRaw(::grpc::ClientContext* context, const ::fitness::LoginRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::fitness::RegisterResponse>* AsyncRegisterUserRaw(::grpc::ClientContext* context, const ::fitness::RegisterRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::fitness::RegisterResponse>* PrepareAsyncRegisterUserRaw(::grpc::ClientContext* context, const ::fitness::RegisterRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::fitness::TrainerList>* AsyncGetTrainersRaw(::grpc::ClientContext* context, const ::fitness::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::fitness::TrainerList>* PrepareAsyncGetTrainersRaw(::grpc::ClientContext* context, const ::fitness::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::fitness::TrainerScheduleResponse>* AsyncGetTrainerScheduleRaw(::grpc::ClientContext* context, const ::fitness::TrainerScheduleRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::fitness::TrainerScheduleResponse>* PrepareAsyncGetTrainerScheduleRaw(::grpc::ClientContext* context, const ::fitness::TrainerScheduleRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::fitness::TrainerClientsResponse>* AsyncGetTrainerClientsRaw(::grpc::ClientContext* context, const ::fitness::TrainerClientsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::fitness::TrainerClientsResponse>* PrepareAsyncGetTrainerClientsRaw(::grpc::ClientContext* context, const ::fitness::TrainerClientsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::fitness::ContactList>* AsyncGetContactsRaw(::grpc::ClientContext* context, const ::fitness::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::fitness::ContactList>* PrepareAsyncGetContactsRaw(::grpc::ClientContext* context, const ::fitness::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::fitness::PriceList>* AsyncGetPricesRaw(::grpc::ClientContext* context, const ::fitness::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::fitness::PriceList>* PrepareAsyncGetPricesRaw(::grpc::ClientContext* context, const ::fitness::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::fitness::TrainingBookingResponse>* AsyncBookTrainingRaw(::grpc::ClientContext* context, const ::fitness::TrainingBookingRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::fitness::TrainingBookingResponse>* PrepareAsyncBookTrainingRaw(::grpc::ClientContext* context, const ::fitness::TrainingBookingRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::fitness::BalanceResponse>* AsyncAddBalanceRaw(::grpc::ClientContext* context, const ::fitness::BalanceRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::fitness::BalanceResponse>* PrepareAsyncAddBalanceRaw(::grpc::ClientContext* context, const ::fitness::BalanceRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status GetServices(::grpc::ClientContext* context, const ::fitness::Empty& request, ::fitness::ServiceList* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::fitness::ServiceList>> AsyncGetServices(::grpc::ClientContext* context, const ::fitness::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::fitness::ServiceList>>(AsyncGetServicesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::fitness::ServiceList>> PrepareAsyncGetServices(::grpc::ClientContext* context, const ::fitness::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::fitness::ServiceList>>(PrepareAsyncGetServicesRaw(context, request, cq));
    }
    ::grpc::Status LoginUser(::grpc::ClientContext* context, const ::fitness::LoginRequest& request, ::fitness::LoginResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::fitness::LoginResponse>> AsyncLoginUser(::grpc::ClientContext* context, const ::fitness::LoginRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::fitness::LoginResponse>>(AsyncLoginUserRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::fitness::LoginResponse>> PrepareAsyncLoginUser(::grpc::ClientContext* context, const ::fitness::LoginRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::fitness::LoginResponse>>(PrepareAsyncLoginUserRaw(context, request, cq));
    }
    ::grpc::Status RegisterUser(::grpc::ClientContext* context, const ::fitness::RegisterRequest& request, ::fitness::RegisterResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::fitness::RegisterResponse>> AsyncRegisterUser(::grpc::ClientContext* context, const ::fitness::RegisterRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::fitness::RegisterResponse>>(AsyncRegisterUserRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::fitness::RegisterResponse>> PrepareAsyncRegisterUser(::grpc::ClientContext* context, const ::fitness::RegisterRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::fitness::RegisterResponse>>(PrepareAsyncRegisterUserRaw(context, request, cq));
    }
    ::grpc::Status GetTrainers(::grpc::ClientContext* context, const ::fitness::Empty& request, ::fitness::TrainerList* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::fitness::TrainerList>> AsyncGetTrainers(::grpc::ClientContext* context, const ::fitness::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::fitness::TrainerList>>(AsyncGetTrainersRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::fitness::TrainerList>> PrepareAsyncGetTrainers(::grpc::ClientContext* context, const ::fitness::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::fitness::TrainerList>>(PrepareAsyncGetTrainersRaw(context, request, cq));
    }
    ::grpc::Status GetTrainerSchedule(::grpc::ClientContext* context, const ::fitness::TrainerScheduleRequest& request, ::fitness::TrainerScheduleResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::fitness::TrainerScheduleResponse>> AsyncGetTrainerSchedule(::grpc::ClientContext* context, const ::fitness::TrainerScheduleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::fitness::TrainerScheduleResponse>>(AsyncGetTrainerScheduleRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::fitness::TrainerScheduleResponse>> PrepareAsyncGetTrainerSchedule(::grpc::ClientContext* context, const ::fitness::TrainerScheduleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::fitness::TrainerScheduleResponse>>(PrepareAsyncGetTrainerScheduleRaw(context, request, cq));
    }
    ::grpc::Status GetTrainerClients(::grpc::ClientContext* context, const ::fitness::TrainerClientsRequest& request, ::fitness::TrainerClientsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::fitness::TrainerClientsResponse>> AsyncGetTrainerClients(::grpc::ClientContext* context, const ::fitness::TrainerClientsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::fitness::TrainerClientsResponse>>(AsyncGetTrainerClientsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::fitness::TrainerClientsResponse>> PrepareAsyncGetTrainerClients(::grpc::ClientContext* context, const ::fitness::TrainerClientsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::fitness::TrainerClientsResponse>>(PrepareAsyncGetTrainerClientsRaw(context, request, cq));
    }
    ::grpc::Status GetContacts(::grpc::ClientContext* context, const ::fitness::Empty& request, ::fitness::ContactList* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::fitness::ContactList>> AsyncGetContacts(::grpc::ClientContext* context, const ::fitness::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::fitness::ContactList>>(AsyncGetContactsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::fitness::ContactList>> PrepareAsyncGetContacts(::grpc::ClientContext* context, const ::fitness::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::fitness::ContactList>>(PrepareAsyncGetContactsRaw(context, request, cq));
    }
    ::grpc::Status GetPrices(::grpc::ClientContext* context, const ::fitness::Empty& request, ::fitness::PriceList* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::fitness::PriceList>> AsyncGetPrices(::grpc::ClientContext* context, const ::fitness::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::fitness::PriceList>>(AsyncGetPricesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::fitness::PriceList>> PrepareAsyncGetPrices(::grpc::ClientContext* context, const ::fitness::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::fitness::PriceList>>(PrepareAsyncGetPricesRaw(context, request, cq));
    }
    ::grpc::Status BookTraining(::grpc::ClientContext* context, const ::fitness::TrainingBookingRequest& request, ::fitness::TrainingBookingResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::fitness::TrainingBookingResponse>> AsyncBookTraining(::grpc::ClientContext* context, const ::fitness::TrainingBookingRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::fitness::TrainingBookingResponse>>(AsyncBookTrainingRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::fitness::TrainingBookingResponse>> PrepareAsyncBookTraining(::grpc::ClientContext* context, const ::fitness::TrainingBookingRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::fitness::TrainingBookingResponse>>(PrepareAsyncBookTrainingRaw(context, request, cq));
    }
    ::grpc::Status AddBalance(::grpc::ClientContext* context, const ::fitness::BalanceRequest& request, ::fitness::BalanceResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::fitness::BalanceResponse>> AsyncAddBalance(::grpc::ClientContext* context, const ::fitness::BalanceRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::fitness::BalanceResponse>>(AsyncAddBalanceRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::fitness::BalanceResponse>> PrepareAsyncAddBalance(::grpc::ClientContext* context, const ::fitness::BalanceRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::fitness::BalanceResponse>>(PrepareAsyncAddBalanceRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void GetServices(::grpc::ClientContext* context, const ::fitness::Empty* request, ::fitness::ServiceList* response, std::function<void(::grpc::Status)>) override;
      void GetServices(::grpc::ClientContext* context, const ::fitness::Empty* request, ::fitness::ServiceList* response, ::grpc::ClientUnaryReactor* reactor) override;
      void LoginUser(::grpc::ClientContext* context, const ::fitness::LoginRequest* request, ::fitness::LoginResponse* response, std::function<void(::grpc::Status)>) override;
      void LoginUser(::grpc::ClientContext* context, const ::fitness::LoginRequest* request, ::fitness::LoginResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void RegisterUser(::grpc::ClientContext* context, const ::fitness::RegisterRequest* request, ::fitness::RegisterResponse* response, std::function<void(::grpc::Status)>) override;
      void RegisterUser(::grpc::ClientContext* context, const ::fitness::RegisterRequest* request, ::fitness::RegisterResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetTrainers(::grpc::ClientContext* context, const ::fitness::Empty* request, ::fitness::TrainerList* response, std::function<void(::grpc::Status)>) override;
      void GetTrainers(::grpc::ClientContext* context, const ::fitness::Empty* request, ::fitness::TrainerList* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetTrainerSchedule(::grpc::ClientContext* context, const ::fitness::TrainerScheduleRequest* request, ::fitness::TrainerScheduleResponse* response, std::function<void(::grpc::Status)>) override;
      void GetTrainerSchedule(::grpc::ClientContext* context, const ::fitness::TrainerScheduleRequest* request, ::fitness::TrainerScheduleResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetTrainerClients(::grpc::ClientContext* context, const ::fitness::TrainerClientsRequest* request, ::fitness::TrainerClientsResponse* response, std::function<void(::grpc::Status)>) override;
      void GetTrainerClients(::grpc::ClientContext* context, const ::fitness::TrainerClientsRequest* request, ::fitness::TrainerClientsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetContacts(::grpc::ClientContext* context, const ::fitness::Empty* request, ::fitness::ContactList* response, std::function<void(::grpc::Status)>) override;
      void GetContacts(::grpc::ClientContext* context, const ::fitness::Empty* request, ::fitness::ContactList* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetPrices(::grpc::ClientContext* context, const ::fitness::Empty* request, ::fitness::PriceList* response, std::function<void(::grpc::Status)>) override;
      void GetPrices(::grpc::ClientContext* context, const ::fitness::Empty* request, ::fitness::PriceList* response, ::grpc::ClientUnaryReactor* reactor) override;
      void BookTraining(::grpc::ClientContext* context, const ::fitness::TrainingBookingRequest* request, ::fitness::TrainingBookingResponse* response, std::function<void(::grpc::Status)>) override;
      void BookTraining(::grpc::ClientContext* context, const ::fitness::TrainingBookingRequest* request, ::fitness::TrainingBookingResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void AddBalance(::grpc::ClientContext* context, const ::fitness::BalanceRequest* request, ::fitness::BalanceResponse* response, std::function<void(::grpc::Status)>) override;
      void AddBalance(::grpc::ClientContext* context, const ::fitness::BalanceRequest* request, ::fitness::BalanceResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::fitness::ServiceList>* AsyncGetServicesRaw(::grpc::ClientContext* context, const ::fitness::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::fitness::ServiceList>* PrepareAsyncGetServicesRaw(::grpc::ClientContext* context, const ::fitness::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::fitness::LoginResponse>* AsyncLoginUserRaw(::grpc::ClientContext* context, const ::fitness::LoginRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::fitness::LoginResponse>* PrepareAsyncLoginUserRaw(::grpc::ClientContext* context, const ::fitness::LoginRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::fitness::RegisterResponse>* AsyncRegisterUserRaw(::grpc::ClientContext* context, const ::fitness::RegisterRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::fitness::RegisterResponse>* PrepareAsyncRegisterUserRaw(::grpc::ClientContext* context, const ::fitness::RegisterRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::fitness::TrainerList>* AsyncGetTrainersRaw(::grpc::ClientContext* context, const ::fitness::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::fitness::TrainerList>* PrepareAsyncGetTrainersRaw(::grpc::ClientContext* context, const ::fitness::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::fitness::TrainerScheduleResponse>* AsyncGetTrainerScheduleRaw(::grpc::ClientContext* context, const ::fitness::TrainerScheduleRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::fitness::TrainerScheduleResponse>* PrepareAsyncGetTrainerScheduleRaw(::grpc::ClientContext* context, const ::fitness::TrainerScheduleRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::fitness::TrainerClientsResponse>* AsyncGetTrainerClientsRaw(::grpc::ClientContext* context, const ::fitness::TrainerClientsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::fitness::TrainerClientsResponse>* PrepareAsyncGetTrainerClientsRaw(::grpc::ClientContext* context, const ::fitness::TrainerClientsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::fitness::ContactList>* AsyncGetContactsRaw(::grpc::ClientContext* context, const ::fitness::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::fitness::ContactList>* PrepareAsyncGetContactsRaw(::grpc::ClientContext* context, const ::fitness::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::fitness::PriceList>* AsyncGetPricesRaw(::grpc::ClientContext* context, const ::fitness::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::fitness::PriceList>* PrepareAsyncGetPricesRaw(::grpc::ClientContext* context, const ::fitness::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::fitness::TrainingBookingResponse>* AsyncBookTrainingRaw(::grpc::ClientContext* context, const ::fitness::TrainingBookingRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::fitness::TrainingBookingResponse>* PrepareAsyncBookTrainingRaw(::grpc::ClientContext* context, const ::fitness::TrainingBookingRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::fitness::BalanceResponse>* AsyncAddBalanceRaw(::grpc::ClientContext* context, const ::fitness::BalanceRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::fitness::BalanceResponse>* PrepareAsyncAddBalanceRaw(::grpc::ClientContext* context, const ::fitness::BalanceRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_GetServices_;
    const ::grpc::internal::RpcMethod rpcmethod_LoginUser_;
    const ::grpc::internal::RpcMethod rpcmethod_RegisterUser_;
    const ::grpc::internal::RpcMethod rpcmethod_GetTrainers_;
    const ::grpc::internal::RpcMethod rpcmethod_GetTrainerSchedule_;
    const ::grpc::internal::RpcMethod rpcmethod_GetTrainerClients_;
    const ::grpc::internal::RpcMethod rpcmethod_GetContacts_;
    const ::grpc::internal::RpcMethod rpcmethod_GetPrices_;
    const ::grpc::internal::RpcMethod rpcmethod_BookTraining_;
    const ::grpc::internal::RpcMethod rpcmethod_AddBalance_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status GetServices(::grpc::ServerContext* context, const ::fitness::Empty* request, ::fitness::ServiceList* response);
    virtual ::grpc::Status LoginUser(::grpc::ServerContext* context, const ::fitness::LoginRequest* request, ::fitness::LoginResponse* response);
    virtual ::grpc::Status RegisterUser(::grpc::ServerContext* context, const ::fitness::RegisterRequest* request, ::fitness::RegisterResponse* response);
    virtual ::grpc::Status GetTrainers(::grpc::ServerContext* context, const ::fitness::Empty* request, ::fitness::TrainerList* response);
    virtual ::grpc::Status GetTrainerSchedule(::grpc::ServerContext* context, const ::fitness::TrainerScheduleRequest* request, ::fitness::TrainerScheduleResponse* response);
    virtual ::grpc::Status GetTrainerClients(::grpc::ServerContext* context, const ::fitness::TrainerClientsRequest* request, ::fitness::TrainerClientsResponse* response);
    virtual ::grpc::Status GetContacts(::grpc::ServerContext* context, const ::fitness::Empty* request, ::fitness::ContactList* response);
    virtual ::grpc::Status GetPrices(::grpc::ServerContext* context, const ::fitness::Empty* request, ::fitness::PriceList* response);
    virtual ::grpc::Status BookTraining(::grpc::ServerContext* context, const ::fitness::TrainingBookingRequest* request, ::fitness::TrainingBookingResponse* response);
    virtual ::grpc::Status AddBalance(::grpc::ServerContext* context, const ::fitness::BalanceRequest* request, ::fitness::BalanceResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_GetServices : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetServices() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_GetServices() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetServices(::grpc::ServerContext* /*context*/, const ::fitness::Empty* /*request*/, ::fitness::ServiceList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetServices(::grpc::ServerContext* context, ::fitness::Empty* request, ::grpc::ServerAsyncResponseWriter< ::fitness::ServiceList>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_LoginUser : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_LoginUser() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_LoginUser() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LoginUser(::grpc::ServerContext* /*context*/, const ::fitness::LoginRequest* /*request*/, ::fitness::LoginResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLoginUser(::grpc::ServerContext* context, ::fitness::LoginRequest* request, ::grpc::ServerAsyncResponseWriter< ::fitness::LoginResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_RegisterUser : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_RegisterUser() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_RegisterUser() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RegisterUser(::grpc::ServerContext* /*context*/, const ::fitness::RegisterRequest* /*request*/, ::fitness::RegisterResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRegisterUser(::grpc::ServerContext* context, ::fitness::RegisterRequest* request, ::grpc::ServerAsyncResponseWriter< ::fitness::RegisterResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetTrainers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetTrainers() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_GetTrainers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTrainers(::grpc::ServerContext* /*context*/, const ::fitness::Empty* /*request*/, ::fitness::TrainerList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetTrainers(::grpc::ServerContext* context, ::fitness::Empty* request, ::grpc::ServerAsyncResponseWriter< ::fitness::TrainerList>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetTrainerSchedule : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetTrainerSchedule() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_GetTrainerSchedule() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTrainerSchedule(::grpc::ServerContext* /*context*/, const ::fitness::TrainerScheduleRequest* /*request*/, ::fitness::TrainerScheduleResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetTrainerSchedule(::grpc::ServerContext* context, ::fitness::TrainerScheduleRequest* request, ::grpc::ServerAsyncResponseWriter< ::fitness::TrainerScheduleResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetTrainerClients : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetTrainerClients() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_GetTrainerClients() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTrainerClients(::grpc::ServerContext* /*context*/, const ::fitness::TrainerClientsRequest* /*request*/, ::fitness::TrainerClientsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetTrainerClients(::grpc::ServerContext* context, ::fitness::TrainerClientsRequest* request, ::grpc::ServerAsyncResponseWriter< ::fitness::TrainerClientsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetContacts : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetContacts() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_GetContacts() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetContacts(::grpc::ServerContext* /*context*/, const ::fitness::Empty* /*request*/, ::fitness::ContactList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetContacts(::grpc::ServerContext* context, ::fitness::Empty* request, ::grpc::ServerAsyncResponseWriter< ::fitness::ContactList>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetPrices : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetPrices() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_GetPrices() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPrices(::grpc::ServerContext* /*context*/, const ::fitness::Empty* /*request*/, ::fitness::PriceList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetPrices(::grpc::ServerContext* context, ::fitness::Empty* request, ::grpc::ServerAsyncResponseWriter< ::fitness::PriceList>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_BookTraining : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_BookTraining() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_BookTraining() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BookTraining(::grpc::ServerContext* /*context*/, const ::fitness::TrainingBookingRequest* /*request*/, ::fitness::TrainingBookingResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestBookTraining(::grpc::ServerContext* context, ::fitness::TrainingBookingRequest* request, ::grpc::ServerAsyncResponseWriter< ::fitness::TrainingBookingResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_AddBalance : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_AddBalance() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_AddBalance() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddBalance(::grpc::ServerContext* /*context*/, const ::fitness::BalanceRequest* /*request*/, ::fitness::BalanceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAddBalance(::grpc::ServerContext* context, ::fitness::BalanceRequest* request, ::grpc::ServerAsyncResponseWriter< ::fitness::BalanceResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_GetServices<WithAsyncMethod_LoginUser<WithAsyncMethod_RegisterUser<WithAsyncMethod_GetTrainers<WithAsyncMethod_GetTrainerSchedule<WithAsyncMethod_GetTrainerClients<WithAsyncMethod_GetContacts<WithAsyncMethod_GetPrices<WithAsyncMethod_BookTraining<WithAsyncMethod_AddBalance<Service > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_GetServices : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetServices() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::fitness::Empty, ::fitness::ServiceList>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::fitness::Empty* request, ::fitness::ServiceList* response) { return this->GetServices(context, request, response); }));}
    void SetMessageAllocatorFor_GetServices(
        ::grpc::MessageAllocator< ::fitness::Empty, ::fitness::ServiceList>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::fitness::Empty, ::fitness::ServiceList>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetServices() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetServices(::grpc::ServerContext* /*context*/, const ::fitness::Empty* /*request*/, ::fitness::ServiceList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetServices(
      ::grpc::CallbackServerContext* /*context*/, const ::fitness::Empty* /*request*/, ::fitness::ServiceList* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_LoginUser : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_LoginUser() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::fitness::LoginRequest, ::fitness::LoginResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::fitness::LoginRequest* request, ::fitness::LoginResponse* response) { return this->LoginUser(context, request, response); }));}
    void SetMessageAllocatorFor_LoginUser(
        ::grpc::MessageAllocator< ::fitness::LoginRequest, ::fitness::LoginResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::fitness::LoginRequest, ::fitness::LoginResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_LoginUser() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LoginUser(::grpc::ServerContext* /*context*/, const ::fitness::LoginRequest* /*request*/, ::fitness::LoginResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* LoginUser(
      ::grpc::CallbackServerContext* /*context*/, const ::fitness::LoginRequest* /*request*/, ::fitness::LoginResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_RegisterUser : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_RegisterUser() {
      ::grpc::Service::MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::fitness::RegisterRequest, ::fitness::RegisterResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::fitness::RegisterRequest* request, ::fitness::RegisterResponse* response) { return this->RegisterUser(context, request, response); }));}
    void SetMessageAllocatorFor_RegisterUser(
        ::grpc::MessageAllocator< ::fitness::RegisterRequest, ::fitness::RegisterResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::fitness::RegisterRequest, ::fitness::RegisterResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_RegisterUser() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RegisterUser(::grpc::ServerContext* /*context*/, const ::fitness::RegisterRequest* /*request*/, ::fitness::RegisterResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* RegisterUser(
      ::grpc::CallbackServerContext* /*context*/, const ::fitness::RegisterRequest* /*request*/, ::fitness::RegisterResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetTrainers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetTrainers() {
      ::grpc::Service::MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::fitness::Empty, ::fitness::TrainerList>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::fitness::Empty* request, ::fitness::TrainerList* response) { return this->GetTrainers(context, request, response); }));}
    void SetMessageAllocatorFor_GetTrainers(
        ::grpc::MessageAllocator< ::fitness::Empty, ::fitness::TrainerList>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::fitness::Empty, ::fitness::TrainerList>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetTrainers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTrainers(::grpc::ServerContext* /*context*/, const ::fitness::Empty* /*request*/, ::fitness::TrainerList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetTrainers(
      ::grpc::CallbackServerContext* /*context*/, const ::fitness::Empty* /*request*/, ::fitness::TrainerList* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetTrainerSchedule : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetTrainerSchedule() {
      ::grpc::Service::MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::fitness::TrainerScheduleRequest, ::fitness::TrainerScheduleResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::fitness::TrainerScheduleRequest* request, ::fitness::TrainerScheduleResponse* response) { return this->GetTrainerSchedule(context, request, response); }));}
    void SetMessageAllocatorFor_GetTrainerSchedule(
        ::grpc::MessageAllocator< ::fitness::TrainerScheduleRequest, ::fitness::TrainerScheduleResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::fitness::TrainerScheduleRequest, ::fitness::TrainerScheduleResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetTrainerSchedule() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTrainerSchedule(::grpc::ServerContext* /*context*/, const ::fitness::TrainerScheduleRequest* /*request*/, ::fitness::TrainerScheduleResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetTrainerSchedule(
      ::grpc::CallbackServerContext* /*context*/, const ::fitness::TrainerScheduleRequest* /*request*/, ::fitness::TrainerScheduleResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetTrainerClients : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetTrainerClients() {
      ::grpc::Service::MarkMethodCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::fitness::TrainerClientsRequest, ::fitness::TrainerClientsResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::fitness::TrainerClientsRequest* request, ::fitness::TrainerClientsResponse* response) { return this->GetTrainerClients(context, request, response); }));}
    void SetMessageAllocatorFor_GetTrainerClients(
        ::grpc::MessageAllocator< ::fitness::TrainerClientsRequest, ::fitness::TrainerClientsResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::fitness::TrainerClientsRequest, ::fitness::TrainerClientsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetTrainerClients() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTrainerClients(::grpc::ServerContext* /*context*/, const ::fitness::TrainerClientsRequest* /*request*/, ::fitness::TrainerClientsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetTrainerClients(
      ::grpc::CallbackServerContext* /*context*/, const ::fitness::TrainerClientsRequest* /*request*/, ::fitness::TrainerClientsResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetContacts : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetContacts() {
      ::grpc::Service::MarkMethodCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::fitness::Empty, ::fitness::ContactList>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::fitness::Empty* request, ::fitness::ContactList* response) { return this->GetContacts(context, request, response); }));}
    void SetMessageAllocatorFor_GetContacts(
        ::grpc::MessageAllocator< ::fitness::Empty, ::fitness::ContactList>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(6);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::fitness::Empty, ::fitness::ContactList>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetContacts() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetContacts(::grpc::ServerContext* /*context*/, const ::fitness::Empty* /*request*/, ::fitness::ContactList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetContacts(
      ::grpc::CallbackServerContext* /*context*/, const ::fitness::Empty* /*request*/, ::fitness::ContactList* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetPrices : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetPrices() {
      ::grpc::Service::MarkMethodCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::fitness::Empty, ::fitness::PriceList>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::fitness::Empty* request, ::fitness::PriceList* response) { return this->GetPrices(context, request, response); }));}
    void SetMessageAllocatorFor_GetPrices(
        ::grpc::MessageAllocator< ::fitness::Empty, ::fitness::PriceList>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(7);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::fitness::Empty, ::fitness::PriceList>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetPrices() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPrices(::grpc::ServerContext* /*context*/, const ::fitness::Empty* /*request*/, ::fitness::PriceList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetPrices(
      ::grpc::CallbackServerContext* /*context*/, const ::fitness::Empty* /*request*/, ::fitness::PriceList* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_BookTraining : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_BookTraining() {
      ::grpc::Service::MarkMethodCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::fitness::TrainingBookingRequest, ::fitness::TrainingBookingResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::fitness::TrainingBookingRequest* request, ::fitness::TrainingBookingResponse* response) { return this->BookTraining(context, request, response); }));}
    void SetMessageAllocatorFor_BookTraining(
        ::grpc::MessageAllocator< ::fitness::TrainingBookingRequest, ::fitness::TrainingBookingResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(8);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::fitness::TrainingBookingRequest, ::fitness::TrainingBookingResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_BookTraining() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BookTraining(::grpc::ServerContext* /*context*/, const ::fitness::TrainingBookingRequest* /*request*/, ::fitness::TrainingBookingResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* BookTraining(
      ::grpc::CallbackServerContext* /*context*/, const ::fitness::TrainingBookingRequest* /*request*/, ::fitness::TrainingBookingResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_AddBalance : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_AddBalance() {
      ::grpc::Service::MarkMethodCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::fitness::BalanceRequest, ::fitness::BalanceResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::fitness::BalanceRequest* request, ::fitness::BalanceResponse* response) { return this->AddBalance(context, request, response); }));}
    void SetMessageAllocatorFor_AddBalance(
        ::grpc::MessageAllocator< ::fitness::BalanceRequest, ::fitness::BalanceResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(9);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::fitness::BalanceRequest, ::fitness::BalanceResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_AddBalance() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddBalance(::grpc::ServerContext* /*context*/, const ::fitness::BalanceRequest* /*request*/, ::fitness::BalanceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* AddBalance(
      ::grpc::CallbackServerContext* /*context*/, const ::fitness::BalanceRequest* /*request*/, ::fitness::BalanceResponse* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_GetServices<WithCallbackMethod_LoginUser<WithCallbackMethod_RegisterUser<WithCallbackMethod_GetTrainers<WithCallbackMethod_GetTrainerSchedule<WithCallbackMethod_GetTrainerClients<WithCallbackMethod_GetContacts<WithCallbackMethod_GetPrices<WithCallbackMethod_BookTraining<WithCallbackMethod_AddBalance<Service > > > > > > > > > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_GetServices : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetServices() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_GetServices() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetServices(::grpc::ServerContext* /*context*/, const ::fitness::Empty* /*request*/, ::fitness::ServiceList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_LoginUser : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_LoginUser() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_LoginUser() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LoginUser(::grpc::ServerContext* /*context*/, const ::fitness::LoginRequest* /*request*/, ::fitness::LoginResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_RegisterUser : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_RegisterUser() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_RegisterUser() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RegisterUser(::grpc::ServerContext* /*context*/, const ::fitness::RegisterRequest* /*request*/, ::fitness::RegisterResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetTrainers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetTrainers() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_GetTrainers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTrainers(::grpc::ServerContext* /*context*/, const ::fitness::Empty* /*request*/, ::fitness::TrainerList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetTrainerSchedule : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetTrainerSchedule() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_GetTrainerSchedule() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTrainerSchedule(::grpc::ServerContext* /*context*/, const ::fitness::TrainerScheduleRequest* /*request*/, ::fitness::TrainerScheduleResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetTrainerClients : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetTrainerClients() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_GetTrainerClients() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTrainerClients(::grpc::ServerContext* /*context*/, const ::fitness::TrainerClientsRequest* /*request*/, ::fitness::TrainerClientsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetContacts : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetContacts() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_GetContacts() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetContacts(::grpc::ServerContext* /*context*/, const ::fitness::Empty* /*request*/, ::fitness::ContactList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetPrices : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetPrices() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_GetPrices() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPrices(::grpc::ServerContext* /*context*/, const ::fitness::Empty* /*request*/, ::fitness::PriceList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_BookTraining : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_BookTraining() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_BookTraining() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BookTraining(::grpc::ServerContext* /*context*/, const ::fitness::TrainingBookingRequest* /*request*/, ::fitness::TrainingBookingResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_AddBalance : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_AddBalance() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_AddBalance() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddBalance(::grpc::ServerContext* /*context*/, const ::fitness::BalanceRequest* /*request*/, ::fitness::BalanceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetServices : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetServices() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_GetServices() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetServices(::grpc::ServerContext* /*context*/, const ::fitness::Empty* /*request*/, ::fitness::ServiceList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetServices(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_LoginUser : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_LoginUser() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_LoginUser() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LoginUser(::grpc::ServerContext* /*context*/, const ::fitness::LoginRequest* /*request*/, ::fitness::LoginResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLoginUser(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_RegisterUser : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_RegisterUser() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_RegisterUser() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RegisterUser(::grpc::ServerContext* /*context*/, const ::fitness::RegisterRequest* /*request*/, ::fitness::RegisterResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRegisterUser(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetTrainers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetTrainers() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_GetTrainers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTrainers(::grpc::ServerContext* /*context*/, const ::fitness::Empty* /*request*/, ::fitness::TrainerList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetTrainers(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetTrainerSchedule : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetTrainerSchedule() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_GetTrainerSchedule() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTrainerSchedule(::grpc::ServerContext* /*context*/, const ::fitness::TrainerScheduleRequest* /*request*/, ::fitness::TrainerScheduleResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetTrainerSchedule(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetTrainerClients : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetTrainerClients() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_GetTrainerClients() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTrainerClients(::grpc::ServerContext* /*context*/, const ::fitness::TrainerClientsRequest* /*request*/, ::fitness::TrainerClientsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetTrainerClients(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetContacts : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetContacts() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_GetContacts() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetContacts(::grpc::ServerContext* /*context*/, const ::fitness::Empty* /*request*/, ::fitness::ContactList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetContacts(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetPrices : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetPrices() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_GetPrices() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPrices(::grpc::ServerContext* /*context*/, const ::fitness::Empty* /*request*/, ::fitness::PriceList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetPrices(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_BookTraining : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_BookTraining() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_BookTraining() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BookTraining(::grpc::ServerContext* /*context*/, const ::fitness::TrainingBookingRequest* /*request*/, ::fitness::TrainingBookingResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestBookTraining(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_AddBalance : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_AddBalance() {
      ::grpc::Service::MarkMethodRaw(9);
    }
    ~WithRawMethod_AddBalance() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddBalance(::grpc::ServerContext* /*context*/, const ::fitness::BalanceRequest* /*request*/, ::fitness::BalanceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAddBalance(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetServices : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetServices() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetServices(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetServices() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetServices(::grpc::ServerContext* /*context*/, const ::fitness::Empty* /*request*/, ::fitness::ServiceList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetServices(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_LoginUser : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_LoginUser() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->LoginUser(context, request, response); }));
    }
    ~WithRawCallbackMethod_LoginUser() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LoginUser(::grpc::ServerContext* /*context*/, const ::fitness::LoginRequest* /*request*/, ::fitness::LoginResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* LoginUser(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_RegisterUser : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_RegisterUser() {
      ::grpc::Service::MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->RegisterUser(context, request, response); }));
    }
    ~WithRawCallbackMethod_RegisterUser() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RegisterUser(::grpc::ServerContext* /*context*/, const ::fitness::RegisterRequest* /*request*/, ::fitness::RegisterResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* RegisterUser(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetTrainers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetTrainers() {
      ::grpc::Service::MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetTrainers(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetTrainers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTrainers(::grpc::ServerContext* /*context*/, const ::fitness::Empty* /*request*/, ::fitness::TrainerList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetTrainers(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetTrainerSchedule : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetTrainerSchedule() {
      ::grpc::Service::MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetTrainerSchedule(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetTrainerSchedule() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTrainerSchedule(::grpc::ServerContext* /*context*/, const ::fitness::TrainerScheduleRequest* /*request*/, ::fitness::TrainerScheduleResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetTrainerSchedule(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetTrainerClients : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetTrainerClients() {
      ::grpc::Service::MarkMethodRawCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetTrainerClients(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetTrainerClients() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTrainerClients(::grpc::ServerContext* /*context*/, const ::fitness::TrainerClientsRequest* /*request*/, ::fitness::TrainerClientsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetTrainerClients(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetContacts : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetContacts() {
      ::grpc::Service::MarkMethodRawCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetContacts(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetContacts() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetContacts(::grpc::ServerContext* /*context*/, const ::fitness::Empty* /*request*/, ::fitness::ContactList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetContacts(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetPrices : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetPrices() {
      ::grpc::Service::MarkMethodRawCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetPrices(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetPrices() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPrices(::grpc::ServerContext* /*context*/, const ::fitness::Empty* /*request*/, ::fitness::PriceList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetPrices(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_BookTraining : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_BookTraining() {
      ::grpc::Service::MarkMethodRawCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->BookTraining(context, request, response); }));
    }
    ~WithRawCallbackMethod_BookTraining() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BookTraining(::grpc::ServerContext* /*context*/, const ::fitness::TrainingBookingRequest* /*request*/, ::fitness::TrainingBookingResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* BookTraining(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_AddBalance : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_AddBalance() {
      ::grpc::Service::MarkMethodRawCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->AddBalance(context, request, response); }));
    }
    ~WithRawCallbackMethod_AddBalance() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddBalance(::grpc::ServerContext* /*context*/, const ::fitness::BalanceRequest* /*request*/, ::fitness::BalanceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* AddBalance(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetServices : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetServices() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::fitness::Empty, ::fitness::ServiceList>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::fitness::Empty, ::fitness::ServiceList>* streamer) {
                       return this->StreamedGetServices(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetServices() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetServices(::grpc::ServerContext* /*context*/, const ::fitness::Empty* /*request*/, ::fitness::ServiceList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetServices(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::fitness::Empty,::fitness::ServiceList>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_LoginUser : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_LoginUser() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::fitness::LoginRequest, ::fitness::LoginResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::fitness::LoginRequest, ::fitness::LoginResponse>* streamer) {
                       return this->StreamedLoginUser(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_LoginUser() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status LoginUser(::grpc::ServerContext* /*context*/, const ::fitness::LoginRequest* /*request*/, ::fitness::LoginResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedLoginUser(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::fitness::LoginRequest,::fitness::LoginResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_RegisterUser : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_RegisterUser() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::fitness::RegisterRequest, ::fitness::RegisterResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::fitness::RegisterRequest, ::fitness::RegisterResponse>* streamer) {
                       return this->StreamedRegisterUser(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_RegisterUser() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status RegisterUser(::grpc::ServerContext* /*context*/, const ::fitness::RegisterRequest* /*request*/, ::fitness::RegisterResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedRegisterUser(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::fitness::RegisterRequest,::fitness::RegisterResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetTrainers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetTrainers() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::fitness::Empty, ::fitness::TrainerList>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::fitness::Empty, ::fitness::TrainerList>* streamer) {
                       return this->StreamedGetTrainers(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetTrainers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetTrainers(::grpc::ServerContext* /*context*/, const ::fitness::Empty* /*request*/, ::fitness::TrainerList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetTrainers(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::fitness::Empty,::fitness::TrainerList>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetTrainerSchedule : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetTrainerSchedule() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::fitness::TrainerScheduleRequest, ::fitness::TrainerScheduleResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::fitness::TrainerScheduleRequest, ::fitness::TrainerScheduleResponse>* streamer) {
                       return this->StreamedGetTrainerSchedule(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetTrainerSchedule() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetTrainerSchedule(::grpc::ServerContext* /*context*/, const ::fitness::TrainerScheduleRequest* /*request*/, ::fitness::TrainerScheduleResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetTrainerSchedule(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::fitness::TrainerScheduleRequest,::fitness::TrainerScheduleResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetTrainerClients : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetTrainerClients() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler<
          ::fitness::TrainerClientsRequest, ::fitness::TrainerClientsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::fitness::TrainerClientsRequest, ::fitness::TrainerClientsResponse>* streamer) {
                       return this->StreamedGetTrainerClients(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetTrainerClients() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetTrainerClients(::grpc::ServerContext* /*context*/, const ::fitness::TrainerClientsRequest* /*request*/, ::fitness::TrainerClientsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetTrainerClients(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::fitness::TrainerClientsRequest,::fitness::TrainerClientsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetContacts : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetContacts() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler<
          ::fitness::Empty, ::fitness::ContactList>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::fitness::Empty, ::fitness::ContactList>* streamer) {
                       return this->StreamedGetContacts(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetContacts() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetContacts(::grpc::ServerContext* /*context*/, const ::fitness::Empty* /*request*/, ::fitness::ContactList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetContacts(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::fitness::Empty,::fitness::ContactList>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetPrices : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetPrices() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler<
          ::fitness::Empty, ::fitness::PriceList>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::fitness::Empty, ::fitness::PriceList>* streamer) {
                       return this->StreamedGetPrices(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetPrices() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetPrices(::grpc::ServerContext* /*context*/, const ::fitness::Empty* /*request*/, ::fitness::PriceList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetPrices(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::fitness::Empty,::fitness::PriceList>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_BookTraining : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_BookTraining() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::StreamedUnaryHandler<
          ::fitness::TrainingBookingRequest, ::fitness::TrainingBookingResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::fitness::TrainingBookingRequest, ::fitness::TrainingBookingResponse>* streamer) {
                       return this->StreamedBookTraining(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_BookTraining() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status BookTraining(::grpc::ServerContext* /*context*/, const ::fitness::TrainingBookingRequest* /*request*/, ::fitness::TrainingBookingResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedBookTraining(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::fitness::TrainingBookingRequest,::fitness::TrainingBookingResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_AddBalance : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_AddBalance() {
      ::grpc::Service::MarkMethodStreamed(9,
        new ::grpc::internal::StreamedUnaryHandler<
          ::fitness::BalanceRequest, ::fitness::BalanceResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::fitness::BalanceRequest, ::fitness::BalanceResponse>* streamer) {
                       return this->StreamedAddBalance(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_AddBalance() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status AddBalance(::grpc::ServerContext* /*context*/, const ::fitness::BalanceRequest* /*request*/, ::fitness::BalanceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedAddBalance(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::fitness::BalanceRequest,::fitness::BalanceResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_GetServices<WithStreamedUnaryMethod_LoginUser<WithStreamedUnaryMethod_RegisterUser<WithStreamedUnaryMethod_GetTrainers<WithStreamedUnaryMethod_GetTrainerSchedule<WithStreamedUnaryMethod_GetTrainerClients<WithStreamedUnaryMethod_GetContacts<WithStreamedUnaryMethod_GetPrices<WithStreamedUnaryMethod_BookTraining<WithStreamedUnaryMethod_AddBalance<Service > > > > > > > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_GetServices<WithStreamedUnaryMethod_LoginUser<WithStreamedUnaryMethod_RegisterUser<WithStreamedUnaryMethod_GetTrainers<WithStreamedUnaryMethod_GetTrainerSchedule<WithStreamedUnaryMethod_GetTrainerClients<WithStreamedUnaryMethod_GetContacts<WithStreamedUnaryMethod_GetPrices<WithStreamedUnaryMethod_BookTraining<WithStreamedUnaryMethod_AddBalance<Service > > > > > > > > > > StreamedService;
};

}  // namespace fitness


#endif  // GRPC_store_2eproto__INCLUDED
